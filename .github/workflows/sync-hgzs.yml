name: 同步AdGuard规则文件（带统计信息）

on:
  schedule:
    # 每7天 UTC 时间 0 点执行（北京时间 8 点）
    - cron: '0 0 */7 * *'
  workflow_dispatch:  # 允许手动触发

jobs:
  sync-file:
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码库
        uses: actions/checkout@v4

      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          pip install requests chardet

      - name: 同步文件并统计AdGuard规则
        run: |
          import requests
          import chardet
          import re
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry
          from datetime import datetime

          # 定义要同步的文件列表
          file_urls = [
              ("http://hgzspj.51vip.biz/hg.txt", "hg.txt"),
              ("http://hgzspj.51vip.biz/hg1.txt", "hg1.txt"),
              ("http://hgzspj.51vip.biz/yx.txt", "yx.txt")
          ]

          success_count = 0
          error_messages = []

          # AdGuard规则的正则表达式模式
          # 匹配常见的AdGuard过滤规则格式
          adguard_rule_pattern = re.compile(
              r'^(\|{1,2}[^|]+\|{0,2}|@@\|{1,2}[^|]+\|{0,2}|'  # 基本域名过滤
              r'\*[^*]+\*|@@\*[^*]+\*|'  # 通配符过滤
              r'\/.*\/.*|@@\/.*\/.*|'  # 正则表达式过滤
              r'\$([a-z-]+(=[^,]+)?(,[a-z-]+(=[^,]+)?)*)$'  # 选项修饰符
              r')', re.IGNORECASE
          )

          # 获取当前时间（北京时间）
          beijing_tz = datetime.utcnow().timestamp() + 8 * 3600  # UTC+8
          update_time = datetime.fromtimestamp(beijing_tz).strftime("%Y-%m-%d %H:%M:%S")

          # 创建带重试机制的session
          session = requests.Session()
          retry_strategy = Retry(
              total=3,
              backoff_factor=0.5,
              status_forcelist=[429, 500, 502, 503, 504],
          )
          adapter = HTTPAdapter(max_retries=retry_strategy)
          session.mount("http://", adapter)
          session.mount("https://", adapter)

          for url, save_path in file_urls:
              try:
                  # 发送请求获取文件内容
                  response = session.get(url, timeout=60)
                  response.raise_for_status()  # 检查请求是否成功

                  # 自动检测编码
                  encoding = chardet.detect(response.content)['encoding'] or 'utf-8'
                  content = response.content.decode(encoding)

                  # 过滤掉已存在的元数据行
                  lines = content.splitlines()
                  filtered_lines = [
                      line for line in lines 
                      if not (line.strip().startswith("! Version:") or 
                              line.strip().startswith("! Total count:"))
                  ]

                  # 统计AdGuard规则数量（排除注释和空行）
                  adguard_count = 0
                  for line in filtered_lines:
                      stripped_line = line.strip()
                      # 跳过空行和注释行
                      if not stripped_line or stripped_line.startswith(('!', '#')):
                          continue
                      # 检查是否符合AdGuard规则语法
                      if adguard_rule_pattern.match(stripped_line):
                          adguard_count += 1

                  # 构建元数据头部
                  header = [
                      f"! Version:    # 最后同步时间: {update_time} (北京时间)",
                      f"! Total count: {adguard_count} (仅统计AdGuard规则)"
                  ]

                  # 组合新内容（头部 + 过滤后的内容）
                  new_content = '\n'.join(header + filtered_lines)

                  # 保存文件
                  with open(save_path, 'w', encoding='utf-8') as f:
                      f.write(new_content)
                  print(f"文件已成功同步至 {save_path}，AdGuard规则数量: {adguard_count}")
                  success_count += 1
                  
              except Exception as e:
                  error_msg = f"同步 {url} 失败: {str(e)}"
                  print(error_msg)
                  error_messages.append(error_msg)

          # 如果有任何同步失败，输出错误信息
          if error_messages:
              print("\n同步错误汇总:")
              for msg in error_messages:
                  print(f"- {msg}")
              
          # 如果全部失败则退出码为1，部分成功为0
          exit(1 if success_count == 0 else 0)

          print(f"\n同步完成: 成功 {success_count}/{len(file_urls)} 个文件")
        shell: python {0}

      - name: 提交更改
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # 暂存本地更改
          git stash
          
          # 拉取远程最新代码
          git pull --rebase origin main
          
          # 恢复暂存的更改
          git stash pop || echo "没有需要恢复的暂存内容"
          
          # 添加所有同步的文件
          git add hg.txt hg1.txt yx.txt
          
          # 提交更改，无更改则不提交
          git commit -m "自动同步AdGuard规则文件 $(date +'%Y-%m-%d')" || echo "无更改需提交"
          
          # 推送更改到远程仓库
          git push
        # 如果你的默认分支是master，请将上面的"origin main"改为"origin master"
    